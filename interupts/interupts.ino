// These are the clock frequencies available to the timers /2,/8,/32,/128
// 84Mhz/2 = 42.000 MHz
// 84Mhz/8 = 10.500 MHz
// 84Mhz/32 = 2.625 MHz
// 84Mhz/128 = 656.250 KHz
//
// 42Mhz/44.1Khz = 952.38
// 10.5Mhz/44.1Khz = 238.09
// 2.625Hmz/44.1Khz = 59.5
// 656Khz/44.1Khz = 14.88 // 131200 / 656000 = .2 (.2 seconds)

// 84Mhz/44.1Khz = 1904 instructions per tick

#include "./Waveforms.h"
#include "./Scales.h"

const int led_pin = 13;
int state = false;
int interruptCtr = 1;
int S = 0;
int inputPin = 5;
double frequency = 1.0;
//int sample_rate = 44100; //samples per second
int sample_rate = 46875; //samples per second, adjusted to get an integer clocks_per_second

//clock cycles between each audio sample (this must be an integer so your sample rate effectively gets truncated if it doesn't divide evenly)
int clocks_per_sample = 656250 / sample_rate;

int analogOut = 11;
double sample_position = 0;
double sample_period = sample_rate / frequency;

void setup()
{  
  //Ignore this stuff
  pmc_set_writeprotect(false);		 // disable write protection for pmc registers
  pmc_enable_periph_clk(ID_TC7);	 // enable peripheral clock TC7

  // we want wavesel 01 with RC
  TC_Configure(/* clock */TC2,/* channel */1, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | TC_CMR_TCCLKS_TIMER_CLOCK4);
  TC_SetRC(TC2, 1, clocks_per_sample);
  TC_Start(TC2, 1);

  // enable timer interrupts on the timer
  TC2->TC_CHANNEL[1].TC_IER = TC_IER_CPCS; // IER = interrupt enable register
  TC2->TC_CHANNEL[1].TC_IDR = ~TC_IER_CPCS; // IDR = interrupt disable register

  /* Enable the interrupt in the nested vector interrupt controller */
  /* TC4_IRQn where 4 is the timer number * timer channels (3) + the channel number (=(1*3)+1) for timer1 channel1 */
  NVIC_EnableIRQ(TC7_IRQn);
  //stop ignoring this
  
  Serial.begin(9600);
  pinMode(led_pin, OUTPUT);
  pinMode(inputPin, INPUT);
  pinMode(analogOut, OUTPUT);
  pinMode(DAC1, OUTPUT);
  analogWriteResolution(12);
  analogReadResolution(12);
  analogWrite(DAC1, 4095);
}

void loop()
{
  int in = analogRead(inputPin);
  Serial.println(in);
  int size = sizeof(DIATONIC_C)/sizeof(DIATONIC_C[0]);
  int pos = map(in,0,4095,0,size-1);
  pos = constrain(pos,0,size-1);
  frequency = DIATONIC_C[pos];
  
  sample_period = sample_rate / frequency;
}

static inline int SinSample(double pos) {
  double sample_pos = WAVEFORM_SAMPLES * pos;
  int sample_floor = floor(sample_pos);
  double frac = sample_pos - sample_floor;
  return (int)(waveformsTable[0][sample_floor]);
}

static int sintest[512] =  {0x7ff,0x818,0x831,0x84a,0x863,0x87d,0x896,0x8af,0x8c8,0x8e1,0x8fa,0x913,0x92b,0x944,0x95d,0x976,0x98e,0x9a7,0x9c0,0x9d8,0x9f1,0xa09,0xa21,0xa39,0xa51,0xa69,0xa81,0xa99,0xab1,0xac8,0xae0,0xaf7,0xb0f,0xb26,0xb3d,0xb54,0xb6a,0xb81,0xb98,0xbae,0xbc4,0xbda,0xbf0,0xc06,0xc1c,0xc31,0xc46,0xc5c,0xc71,0xc85,0xc9a,0xcae,0xcc3,0xcd7,0xceb,0xcfe,0xd12,0xd25,0xd38,0xd4b,0xd5e,0xd71,0xd83,0xd95,0xda7,0xdb8,0xdca,0xddb,0xdec,0xdfd,0xe0d,0xe1e,0xe2e,0xe3e,0xe4d,0xe5c,0xe6c,0xe7a,0xe89,0xe97,0xea5,0xeb3,0xec1,0xece,0xedb,0xee8,0xef5,0xf01,0xf0d,0xf18,0xf24,0xf2f,0xf3a,0xf45,0xf4f,0xf59,0xf63,0xf6c,0xf75,0xf7e,0xf87,0xf8f,0xf97,0xf9f,0xfa6,0xfad,0xfb4,0xfbb,0xfc1,0xfc7,0xfcd,0xfd2,0xfd7,0xfdc,0xfe0,0xfe4,0xfe8,0xfec,0xfef,0xff2,0xff5,0xff7,0xff9,0xffb,0xffc,0xffd,0xffe,0xffe,0xfff,0xffe,0xffe,0xffd,0xffc,0xffb,0xff9,0xff7,0xff5,0xff2,0xfef,0xfec,0xfe8,0xfe4,0xfe0,0xfdc,0xfd7,0xfd2,0xfcd,0xfc7,0xfc1,0xfbb,0xfb4,0xfad,0xfa6,0xf9f,0xf97,0xf8f,0xf87,0xf7e,0xf75,0xf6c,0xf63,0xf59,0xf4f,0xf45,0xf3a,0xf2f,0xf24,0xf18,0xf0d,0xf01,0xef5,0xee8,0xedb,0xece,0xec1,0xeb3,0xea5,0xe97,0xe89,0xe7a,0xe6c,0xe5c,0xe4d,0xe3e,0xe2e,0xe1e,0xe0d,0xdfd,0xdec,0xddb,0xdca,0xdb8,0xda7,0xd95,0xd83,0xd71,0xd5e,0xd4b,0xd38,0xd25,0xd12,0xcfe,0xceb,0xcd7,0xcc3,0xcae,0xc9a,0xc85,0xc71,0xc5c,0xc46,0xc31,0xc1c,0xc06,0xbf0,0xbda,0xbc4,0xbae,0xb98,0xb81,0xb6a,0xb54,0xb3d,0xb26,0xb0f,0xaf7,0xae0,0xac8,0xab1,0xa99,0xa81,0xa69,0xa51,0xa39,0xa21,0xa09,0x9f1,0x9d8,0x9c0,0x9a7,0x98e,0x976,0x95d,0x944,0x92b,0x913,0x8fa,0x8e1,0x8c8,0x8af,0x896,0x87d,0x863,0x84a,0x831,0x818,0x7ff,0x7e6,0x7cd,0x7b4,0x79b,0x781,0x768,0x74f,0x736,0x71d,0x704,0x6eb,0x6d3,0x6ba,0x6a1,0x688,0x670,0x657,0x63e,0x626,0x60d,0x5f5,0x5dd,0x5c5,0x5ad,0x595,0x57d,0x565,0x54d,0x536,0x51e,0x507,0x4ef,0x4d8,0x4c1,0x4aa,0x494,0x47d,0x466,0x450,0x43a,0x424,0x40e,0x3f8,0x3e2,0x3cd,0x3b8,0x3a2,0x38d,0x379,0x364,0x350,0x33b,0x327,0x313,0x300,0x2ec,0x2d9,0x2c6,0x2b3,0x2a0,0x28d,0x27b,0x269,0x257,0x246,0x234,0x223,0x212,0x201,0x1f1,0x1e0,0x1d0,0x1c0,0x1b1,0x1a2,0x192,0x184,0x175,0x167,0x159,0x14b,0x13d,0x130,0x123,0x116,0x109,0x0fd,0x0f1,0x0e6,0x0da,0x0cf,0x0c4,0x0b9,0x0af,0x0a5,0x09b,0x092,0x089,0x080,0x077,0x06f,0x067,0x05f,0x058,0x051,0x04a,0x043,0x03d,0x037,0x031,0x02c,0x027,0x022,0x01e,0x01a,0x016,0x012,0x00f,0x00c,0x009,0x007,0x005,0x003,0x002,0x001,0x000,0x000,0x000,0x000,0x000,0x001,0x002,0x003,0x005,0x007,0x009,0x00c,0x00f,0x012,0x016,0x01a,0x01e,0x022,0x027,0x02c,0x031,0x037,0x03d,0x043,0x04a,0x051,0x058,0x05f,0x067,0x06f,0x077,0x080,0x089,0x092,0x09b,0x0a5,0x0af,0x0b9,0x0c4,0x0cf,0x0da,0x0e6,0x0f1,0x0fd,0x109,0x116,0x123,0x130,0x13d,0x14b,0x159,0x167,0x175,0x184,0x192,0x1a2,0x1b1,0x1c0,0x1d0,0x1e0,0x1f1,0x201,0x212,0x223,0x234,0x246,0x257,0x269,0x27b,0x28d,0x2a0,0x2b3,0x2c6,0x2d9,0x2ec,0x300,0x313,0x327,0x33b,0x350,0x364,0x379,0x38d,0x3a2,0x3b8,0x3cd,0x3e2,0x3f8,0x40e,0x424,0x43a,0x450,0x466,0x47d,0x494,0x4aa,0x4c1,0x4d8,0x4ef,0x507,0x51e,0x536,0x54d,0x565,0x57d,0x595,0x5ad,0x5c5,0x5dd,0x5f5,0x60d,0x626,0x63e,0x657,0x670,0x688,0x6a1,0x6ba,0x6d3,0x6eb,0x704,0x71d,0x736,0x74f,0x768,0x781,0x79b,0x7b4,0x7cd,0x7e6};

static inline int sampleWaveform(int * waveform, int waveform_samples, double pos) {
  double sample_pos = waveform_samples * pos;
  int sample_floor = floor(sample_pos);
  double frac = sample_pos - sample_floor;
  
  return (int)(waveform[sample_floor]);
  //int value = waveformsTable[0][sample_floor];

  //return value;
}


static inline int nextSample() {
  sample_position++;
  if (sample_position >= sample_period) {
    sample_position -= sample_period;
  }

  //int sample = SinSample(sample_position / sample_period);
  int sample = sampleWaveform(waveformsTable[0], 120, sample_position / sample_period);
  //sample = constrain(sample, 0, 4095);
  return sample;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INTERRUPT HANDLERS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void TC7_Handler()
{
  // We need to get the status to clear it and allow the interrupt to fire again
  TC_GetStatus(TC2, 1);
  dacc_write_conversion_data(DACC_INTERFACE, nextSample());
}
